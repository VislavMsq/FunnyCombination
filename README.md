# Funny Combination - Детальный разбор Clean Architecture

## 1. Введение

**Funny Combination** — это простая игра на запоминание последовательности эмодзи. Однако её основная цель — служить образовательным проектом и эталонной реализацией современной **чистой архитектуры (Clean Architecture)** на Android с использованием передовых технологий.

**Ключевые технологии:**
- **Язык:** Kotlin
- **UI:** Jetpack Compose
- **Асинхронность:** Kotlin Coroutines & Flow
- **Архитектура:** Clean Architecture + MVVM
- **Внедрение зависимостей (DI):** Hilt
- **Хранение данных:** Room
- **Навигация:** Navigation for Compose

Этот документ предназначен для глубокого понимания каждого принятого архитектурного решения.

---

## 2. Фундаментальные принципы архитектуры

В основе проекта лежат три ключевых принципа, которые обеспечивают его гибкость, тестируемость и масштабируемость.

### Принцип №1: Разделение Ответственности (Separation of Concerns)

Код разделен на три независимых слоя, каждый со своей четкой зоной ответственности:

- **`domain` (Слой бизнес-логики):** *Что* приложение делает (правила игры, логика рекордов).
- **`data` (Слой данных):** *Как* и *откуда* приложение получает и сохраняет данные (база данных, сеть).
- **`ui` (Слой представления):** *Как* пользователь взаимодействует с приложением (экраны, кнопки, анимации).

### Принцип №2: Правило Зависимостей (The Dependency Rule)

Это самый важный принцип. **Зависимости в коде могут быть направлены только внутрь — к `domain`-слою.**

```
+----------------------------------------------------+
|  UI Layer                                          |
| (Зависит от Domain, ничего не знает о Data)        |
+------------------------+---------------------------+
                         |                           
                         v                           
+----------------------------------------------------+
|  Domain Layer (Ядро)                               |
| (Ни от кого не зависит, содержит чистую логику)    |
+------------------------+---------------------------+
                         ^                           
                         |                           
+------------------------+---------------------------+
|  Data Layer                                        |
| (Зависит от Domain, ничего не знает о UI)          |
+----------------------------------------------------+
```

- **`ui`** и **`data`** зависят от **`domain`**, но **`domain`** не зависит ни от кого.
- **`ui`** и **`data`** ничего не знают друг о друге.

**Почему это так важно?** Это позволяет ядру бизнес-логики (`domain`) быть полностью независимым. Мы можем полностью заменить базу данных (например, Room на Realm) или даже UI (например, Compose на старый View-подход), и при этом **не придется менять ни строчки кода в `domain`-слое**.

### Принцип №3: Однонаправленный поток данных (Unidirectional Data Flow - UDF)

Внутри `ui`-слоя данные движутся строго в одном направлении, что делает состояние предсказуемым и легко отлаживаемым.

**Цикл UDF:**

```
(Действие пользователя)      (Обновление состояния)
      EVENT --> ViewModel --> STATE --> UI (Перерисовка)
        ^           |           |           |
        |           |           v           |
        +-----------+---- USE CASE <--- REPOSITORY
                  (Бизнес-логика)   (Данные)
```

1.  **UI** отправляет **Событие (Event)** во `ViewModel` (например, `OnPlayClick`).
2.  **ViewModel** обрабатывает событие, вызывая `UseCase` из `domain`-слоя.
3.  **UseCase** выполняет бизнес-логику, обращаясь к `Repository` за данными.
4.  **ViewModel** получает результат и обновляет свое **Состояние (State)**.
5.  **UI**, подписанный на `State`, автоматически и безопасно перерисовывается, чтобы отразить новое состояние.

---

## 3. Глубокий анализ слоев

### 3.1. `domain` — Ядро и мозг приложения

*Папка: `app/src/main/java/com/mosiuk/funnycombination/domain`*

Здесь нет ни одной зависимости от Android SDK. Это чистый Kotlin-модуль.

- **`model/HighScore.kt`**: Это POKO (Plain Old Kotlin Object). Он представляет бизнес-сущность "Рекорд". Он не содержит аннотаций Room или JSON, он просто описывает данные, с которыми работает бизнес-логика.

- **`repository/HighScoreRepository.kt`**: Это **интерфейс-абстракция**. Он определяет **контракт**, который `domain`-слой требует от слоя данных. Он говорит: "Мне нужно уметь получать рекорды и сохранять их", но ему абсолютно все равно, как это будет реализовано — через Room, Firebase или текстовый файл.

- **`usecase/`**: Каждый файл здесь — это один конкретный сценарий. Это реализация **Принципа единственной ответственности (Single Responsibility Principle)**.
  - **`GetBestScoreUseCase.kt`**: Его единственная задача — получить лучший счет. Он вызывает метод репозитория и обрабатывает результат.
  - **`InsertHighScoreIfBestUseCase.kt`**: Содержит бизнес-правило: "сохранить счет, только если он лучший". Он инкапсулирует логику сравнения и получения текущей даты.
  - **`operator fun invoke`**: Этот синтаксический сахар Kotlin позволяет вызывать экземпляр класса как функцию (например, `getBestScoreUseCase()`), делая код во `ViewModel` более лаконичным.

### 3.2. `data` — Реализация доступа к данным

*Папка: `app/src/main/java/com/mosiuk/funnycombination/data`*

Этот слой — "рабочая лошадка", которая выполняет "приказы" `domain`-слоя.

- **`repository/HighScoreRepositoryImpl.kt`**: **Реализация** интерфейса `HighScoreRepository`. Именно здесь происходит магия: вызовы из `domain` превращаются в конкретные SQL-запросы через DAO. 
  - **`withContext(Dispatchers.IO)`**: Все операции с базой данных выполняются в фоновом потоке, чтобы не блокировать UI.

- **`local/` (База данных Room):**
  - **`entity/HighScoreEntity.kt`**: Модель, которая **точно соответствует структуре таблицы** в базе данных. Аннотации `@Entity`, `@PrimaryKey` — это детали реализации Room.
  - **`dao/HighScoreDao.kt`**: Интерфейс, который Room использует для генерации кода. Мы пишем SQL-запросы, а Room делает остальное.
  - **`AppDatabase.kt`**: Конфигурация самой базы данных: список таблиц (entities) и версия.

- **`mapper/HighScoreMappers.kt`**: **Критически важный компонент.** Это "переводчики" на границе слоев. Они преобразуют `HighScoreEntity` (деталь реализации) в `HighScore` (бизнес-сущность). Благодаря им `domain`-слой никогда не увидит `Entity` и останется чистым.

### 3.3. `ui` — Все, что видит пользователь

*Папка: `app/src/main/java/com/mosiuk/funnycombination/ui`*

- **MVVM (Model-View-ViewModel):**
  - **View**: Composable-функции (`...Screen.kt`).
  - **ViewModel**: `...ViewModel.kt`.
  - **Model**: Объект `State` внутри `ViewModel`.

- **`...Contract.kt` (Контракт экрана):**
  - **`State`**: Неизменяемый (immutable) `data class`. Содержит все данные, необходимые для отрисовки экрана. Иммутабельность гарантирует, что состояние предсказуемо.
  - **`Event`**: `sealed interface`, перечисляющий все возможные действия пользователя.
  - **`Effect`**: `sealed interface` для одноразовых событий (навигация, показ Toast). Навигация — это эффект, а не состояние, потому что мы не хотим, чтобы при повороте экрана приложение снова пыталось куда-то перейти.

- **`...ViewModel.kt`**: 
  - **`MutableStateFlow<State>`**: Используется для хранения состояния. UI подписывается на него.
  - **`Channel<Effect>`**: Используется для отправки одноразовых эффектов.
  - **`viewModelScope`**: Короутины, запущенные в этой области, автоматически отменяются, когда `ViewModel` уничтожается, что предотвращает утечки памяти.
  - Внедряет `UseCases` через конструктор и вызывает их для выполнения бизнес-логики.

- **`...Screen.kt` (Composable-функция):**
  - **Stateless (без состояния)**: Функция не хранит никаких данных, а только получает их через параметры. Это делает ее легко переиспользуемой и предсказуемой.
  - **`collectAsStateWithLifecycle()`**: Безопасный способ подписаться на `StateFlow` из `ViewModel`, который учитывает жизненный цикл Composable.

- **`navigation/`**: 
  - **`Screen.kt`**: `sealed class` для создания типобезопасных маршрутов. Исключает ошибки с опечатками в строковых роутах.
  - **`AppNavGraph.kt`**: Центральное место, где маршруты связываются с Composable-экранами.

---

## 4. Внедрение зависимостей (Hilt)

*Папка: `app/src/main/java/com/mosiuk/funnycombination/di`*

Hilt избавляет нас от необходимости создавать и передавать зависимости вручную.

- **Ключевые аннотации:**
  - **`@HiltAndroidApp`**: Ставится над классом `Application`, запуская генерацию кода Hilt.
  - **`@AndroidEntryPoint`**: Ставится над `Activity`, позволяя внедрять в нее зависимости.
  - **`@HiltViewModel`**: Сообщает Hilt, что в эту `ViewModel` нужно внедрять зависимости.
  - **`@Inject constructor`**: Указывает Hilt, как создавать экземпляр этого класса.
  - **`@Module`, `@InstallIn`**: Определяют Hilt-модуль и его жизненный цикл.
  - **`@Provides`**: Используется в модулях для того, чтобы научить Hilt создавать экземпляры классов, которыми мы не владеем (например, из внешних библиотек, как Room).
  - **`@Binds`**: Более эффективный способ сообщить Hilt, какую реализацию использовать для какого-то интерфейса (например, `HighScoreRepositoryImpl` для `HighScoreRepository`).

---

## 5. Пример сквозного потока данных

Рассмотрим сценарий: **Игрок проиграл, и его результат (5 очков) нужно сохранить.**

1.  **`GameViewModel`**: Игра окончена. `ViewModel` отправляет эффект `NavigateToGameOver(5)`. 
2.  **`AppNavGraph`**: Перехватывает эффект и выполняет навигацию на `GameOverScreen`, передавая 5 как аргумент.
3.  **Hilt**: Создает экземпляр `GameOverViewModel`.
4.  **`GameOverViewModel` (`init` блок)**: 
    - Получает счет `5` из `SavedStateHandle`.
    - Вызывает `insertHighScoreIfBestUseCase(5)`.
5.  **`InsertHighScoreIfBestUseCase`**: 
    - Получает текущую дату.
    - Вызывает `repository.insertIfBest(5, "11.08.2025")`.
6.  **`HighScoreRepositoryImpl`**: 
    - Выполняет в `Dispatchers.IO`.
    - Вызывает `dao.getBestScore()` (допустим, возвращает 3).
    - Сравнивает `5 > 3`.
    - Вызывает `dao.insertScore(...)`.
7.  **`GameOverViewModel`**: После сохранения, он вызывает `getBestScoreUseCase()`.
8.  **`GetBestScoreUseCase`**: Получает через репозиторий и DAO новый лучший счет (теперь это 5).
9.  **`GameOverViewModel`**: Получив `5`, обновляет свой `_state`, устанавливая `bestScore = 5` и `isNewBestScore = true`.
10. **`GameOverScreen`**: `collectAsStateWithLifecycle` получает новое состояние и автоматически перерисовывается, показывая текст "New Best Score!" и новый рекорд.

Этот поток демонстрирует, как каждый компонент выполняет свою маленькую, четко определенную роль, работая вместе как единый механизм.

## 6. Как собрать проект

1.  **Клонируйте репозиторий.**
2.  **Откройте проект в Android Studio.**
3.  **Синхронизируйте Gradle.** Студия автоматически скачает все зависимости, указанные в `gradle/libs.versions.toml`.
4.  **Запустите приложение** на эмуляторе или физическом устройстве, нажав кнопку **Run (▶️)**.
